<!DOCTYPE html>
<html>
  <head>
    <title>Enum</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        Enum
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>Provides a set of algorithms that enumerate over collections according to the
<code>Enumerable</code> protocol:</p>

<pre><code>iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)
[2,4,6]
</code></pre>

<p>Some particular types, like dictionaries, yield a specific format on
enumeration. For dicts, the argument is always a <code>{ key, value }</code> tuple:</p>

<pre><code>iex&gt; dict = HashDict.new [a: 1, b: 2]
iex&gt; Enum.map(dict, fn { k, v } -&gt; { k, v * 2 } end)
[a: 2, b: 4]
</code></pre>

<p>Note the functions in the <code>Enum</code> module are eager: they always start
the enumeration of the given collection. The <code>Stream</code> module allows
lazy enumeration of collections and also provides infinite streams.</p>

<p>Since the majority of the functions in <code>Enum</code> enumerate the whole
collection and return a list as result, infinite streams need to
be carefully used with such functions, as they can potentially run
forever, for example:</p>

<pre><code>Enum.each Stream.cycle([1,2,3]), &amp;IO.puts(&amp;1)
</code></pre>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L51" target="_blank" class="view_source">Source</a>

      

      
        <h2 id="functions_summary">Functions summary</h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#all?/2">all?(collection, fun // fn x -&gt; x end)</a></td>
  
    <td class="summary_synopsis"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code> and returns <code>false</code>
if at least one invocation returns <code>false</code>. Otherwise returns <code>true</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#any?/2">any?(collection, fun // fn x -&gt; x end)</a></td>
  
    <td class="summary_synopsis"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code> and returns <code>true</code> if
at least one invocation returns <code>true</code>. Returns <code>false</code> otherwise.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#at/3">at(collection, n, default // nil)</a></td>
  
    <td class="summary_synopsis"><p>Finds the element at the given index (zero-based).
Returns <code>default</code> if index is out of bounds.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#chunks/2">chunks(coll, n)</a></td>
  
    <td class="summary_synopsis"><p>Shortcut to <code>chunks(coll, n, n)</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#chunks/4">chunks(coll, n, step, pad // nil)</a></td>
  
    <td class="summary_synopsis"><p>Returns a collection of lists containing <code>n</code> items each, where
each new chunk starts <code>step</code> elements into the collection.
<code>step</code> is optional and if not passed, defaults to <code>n</code>, i.e.
chunks do not overlap. If the final chunk does not have <code>n</code>
elements to fill the chunk, elements are taken as necessary
from <code>pad</code> if it was passed. If <code>pad</code> is passed and does not
have enough elements to fill the chunk, then the chunk is
returned anyway with less than <code>n</code> elements. If <code>pad</code> is not
passed at all or is nil, then the partial chunk is discarded
from the result.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#chunks_by/2">chunks_by(coll, fun)</a></td>
  
    <td class="summary_synopsis"><p>Splits <code>coll</code> on every element for which <code>fun</code> returns a new value.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#concat/1">concat(enumerables)</a></td>
  
    <td class="summary_synopsis"><p>Given an enumerable of enumerables, concatenate the enumerables into a single list.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#concat/2">concat(left, right)</a></td>
  
    <td class="summary_synopsis"><p>Concatenates the enumerable on the right with the enumerable on the left.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#count/1">count(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns the collection&#39;s size.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#count/2">count(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns the count of items in the collection for which
<code>fun</code> returns <code>true</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#drop/2">drop(collection, count)</a></td>
  
    <td class="summary_synopsis"><p>Drops the first <code>count</code> items from <code>collection</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#drop_while/2">drop_while(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Drops items at the beginning of <code>collection</code> while <code>fun</code> returns <code>true</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#each/2">each(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code>.
Returns <code>:ok</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#empty?/1">empty?(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if the collection is empty, otherwise <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#fetch/2">fetch(collection, n)</a></td>
  
    <td class="summary_synopsis"><p>Finds the element at the given index (zero-based).
Returns <code>{ :ok, element }</code> if found, otherwise <code>:error</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#fetch!/2">fetch!(collection, n)</a></td>
  
    <td class="summary_synopsis"><p>Finds the element at the given index (zero-based).
Raises <code>OutOfBoundsError</code> if the given position
is outside the range of the collection.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#filter/2">filter(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Filters the collection, i.e. returns only those elements
for which <code>fun</code> returns <code>true</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#filter_map/3">filter_map(collection, filter, mapper)</a></td>
  
    <td class="summary_synopsis"><p>Filters the collection and maps its values in one pass.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#find/3">find(collection, ifnone // nil, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns the first item for which <code>fun</code> returns a truthy value. If no such
item is found, returns <code>ifnone</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#find_index/2">find_index(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Similar to <a href="#find/3"><code>find/3</code></a>, but returns the index (zero-based)
of the element instead of the element itself.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#find_value/3">find_value(collection, ifnone // nil, fun)</a></td>
  
    <td class="summary_synopsis"><p>Similar to <a href="#find/3"><code>find/3</code></a>, but returns the value of the function
invocation instead of the element itself.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#first/1">first(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns the first item in the collection or <code>nil</code> otherwise.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#flat_map/2">flat_map(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns a new collection appending the result of invoking <code>fun</code>
on each corresponding item of <code>collection</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#join/2">join(collection, joiner // &quot;&quot;)</a></td>
  
    <td class="summary_synopsis"><p>Joins the given <code>collection</code> according to <code>joiner</code>.
<code>joiner</code> can be either a binary or a list and the
result will be of the same type as <code>joiner</code>. If
<code>joiner</code> is not passed at all, it defaults to an
empty binary.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#map/2">map(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns a new collection, where each item is the result
of invoking <code>fun</code> on each corresponding item of <code>collection</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#map_join/3">map_join(collection, joiner // &quot;&quot;, mapper)</a></td>
  
    <td class="summary_synopsis"><p>Maps and joins the given <code>collection</code> in one pass.
<code>joiner</code> can be either a binary or a list and the
result will be of the same type as <code>joiner</code>. If
<code>joiner</code> is not passed at all, it defaults to an
empty binary.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#map_reduce/3">map_reduce(collection, acc, fun)</a></td>
  
    <td class="summary_synopsis"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code>
while also keeping an accumulator. Returns a tuple where
the first element is the mapped collection and the second
one is the final accumulator.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#max/1">max(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns the maximum value.
Raises <code>EmptyError</code> if the collection is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#max_by/2">max_by(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns the maximum value as calculated by the given function.
Raises <code>EmptyError</code> if the collection is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#member?/2">member?(collection, value)</a></td>
  
    <td class="summary_synopsis"><p>Checks if <code>value</code> exists within the <code>collection</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#min/1">min(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns the minimum value.
Raises <code>EmptyError</code> if the collection is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#min_by/2">min_by(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns the minimum value as calculated by the given function.
Raises <code>EmptyError</code> if the collection is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#partition/2">partition(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Partitions <code>collection</code> into two collections, where the first one contains elements
for which <code>fun</code> returns a truthy value, and the second one -- for which <code>fun</code>
returns <code>false</code> or <code>nil</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#reduce/2">reduce(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Invokes <code>fun</code> for each element in the collection passing that element and the
accumulator <code>acc</code> as arguments. <code>fun</code>&#39;s return value is stored in <code>acc</code>.
The first element of the collection is used as the initial value of <code>acc</code>.
Returns the accumulator.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#reduce/3">reduce(collection, acc, fun)</a></td>
  
    <td class="summary_synopsis"><p>Invokes <code>fun</code> for each element in the collection passing that element and the
accumulator <code>acc</code> as arguments. <code>fun</code>&#39;s return value is stored in <code>acc</code>.
Returns the accumulator.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#reject/2">reject(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns elements of collection for which <code>fun</code> returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#reverse/1">reverse(collection)</a></td>
  
    <td class="summary_synopsis"><p>Reverses the collection.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#shuffle/1">shuffle(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns a list of collection elements shuffled.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#slice/2">slice(coll, arg2)</a></td>
  
    <td class="summary_synopsis"><p>Returns a subset list of the given collection. Dropping elements
until element position <code>range.first</code>, then taking elements until element
position <code>range.last</code> (inclusive).</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#slice/3">slice(coll, start, count)</a></td>
  
    <td class="summary_synopsis"><p>Returns a subset list of the given collection. Dropping elements
until element position <code>start</code>, then taking <code>count</code> elements.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sort/1">sort(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns a sorted list of collection elements. Uses the merge sort algorithm.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sort/2">sort(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Returns a sorted list of collection elements. Uses the merge sort algorithm.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#split/2">split(collection, count)</a></td>
  
    <td class="summary_synopsis"><p>Splits the enumerable into two collections, leaving <code>count</code>
elements in the first one. If <code>count</code> is a negative number,
it starts counting from the back to the beginning of the
collection.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#split_while/2">split_while(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Splits <code>collection</code> in two while <code>fun</code> returns <code>true</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#take/2">take(collection, count)</a></td>
  
    <td class="summary_synopsis"><p>Takes the first <code>count</code> items from the collection.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#take_every/2">take_every(collection, nth)</a></td>
  
    <td class="summary_synopsis"><p>Returns a collection of every <code>nth</code> items in the collection,
starting with the first.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#take_while/2">take_while(collection, fun)</a></td>
  
    <td class="summary_synopsis"><p>Takes the items at the beginning of <code>collection</code> while <code>fun</code> returns <code>true</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#to_list/1">to_list(collection)</a></td>
  
    <td class="summary_synopsis"><p>Convert <code>collection</code> to a list.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#uniq/2">uniq(collection, fun // fn x -&gt; x end)</a></td>
  
    <td class="summary_synopsis"><p>Iterates the enumerable removing all duplicated items.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#with_index/1">with_index(collection)</a></td>
  
    <td class="summary_synopsis"><p>Returns the collection with each element wrapped in a tuple
along side its index.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#zip/2">zip(coll1, coll2)</a></td>
  
    <td class="summary_synopsis"><p>Zips corresponding elements from two collections into one list
of tuples. The number of elements in the resulting list is
dictated by the first enum. If the second list is shorter,
values are filled with <code>nil</code>.</p>
</td>
  
</tr>

        </table>
      

      

      

      
        <div id="types_details" class="details_list">
          <h2>Types</h2>
          <div class="type_detail">
  <p class="typespec" id="t:t/0">
    <a href="#t:t/0">t</a> :: <a href="Enumerable.html#t:t/0">Enumerable.t</a>
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:element/0">
    <a href="#t:element/0">element</a> :: any
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:index/0">
    <a href="#t:index/0">index</a> :: non_neg_integer
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:default/0">
    <a href="#t:default/0">default</a> :: any
  </p>
  
</div>

        </div>
      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="all?/2">
    <strong>all?(collection, fun // fn x -&gt; x end)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>all?(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code> and returns <code>false</code>
if at least one invocation returns <code>false</code>. Otherwise returns <code>true</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.all?([2, 4, 6], fn(x) -&gt; rem(x, 2) == 0 end)
true

iex&gt; Enum.all?([2, 3, 4], fn(x) -&gt; rem(x, 2) == 0 end)
false
</code></pre>

<p>If no function is given, it defaults to checking if
all items in the collection evaluate to <code>true</code>.</p>

<pre><code>iex&gt; Enum.all?([1, 2, 3])
true
iex&gt; Enum.all?([1, nil, 3])
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L162" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="any?/2">
    <strong>any?(collection, fun // fn x -&gt; x end)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>any?(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code> and returns <code>true</code> if
at least one invocation returns <code>true</code>. Returns <code>false</code> otherwise.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.any?([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
false

iex&gt; Enum.any?([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
true
</code></pre>

<p>If no function is given, it defaults to checking if
at least one item in the collection evaluates to <code>true</code>.</p>

<pre><code>iex&gt; Enum.any?([false, false, false])
false
iex&gt; Enum.any?([false, true, false])
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L200" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="at/3">
    <strong>at(collection, n, default // nil)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>at(<a href="#t:t/0">t</a>, integer, <a href="#t:default/0">default</a>) :: <a href="#t:element/0">element</a> | <a href="#t:default/0">default</a></li>
      
    </ul>
  
  <div class="docstring"><p>Finds the element at the given index (zero-based).
Returns <code>default</code> if index is out of bounds.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.at([2, 4, 6], 0)
2
iex&gt; Enum.at([2, 4, 6], 2)
6
iex&gt; Enum.at([2, 4, 6], 4)
nil
iex&gt; Enum.at([2, 4, 6], 4, :none)
:none
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L232" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="chunks/2">
    <strong>chunks(coll, n)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>chunks(<a href="#t:t/0">t</a>, non_neg_integer) :: [[]]</li>
      
    </ul>
  
  <div class="docstring"><p>Shortcut to <code>chunks(coll, n, n)</code>.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1304" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="chunks/4">
    <strong>chunks(coll, n, step, pad // nil)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>chunks(<a href="#t:t/0">t</a>, non_neg_integer, non_neg_integer, [] | nil) :: [[]]</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a collection of lists containing <code>n</code> items each, where
each new chunk starts <code>step</code> elements into the collection.
<code>step</code> is optional and if not passed, defaults to <code>n</code>, i.e.
chunks do not overlap. If the final chunk does not have <code>n</code>
elements to fill the chunk, elements are taken as necessary
from <code>pad</code> if it was passed. If <code>pad</code> is passed and does not
have enough elements to fill the chunk, then the chunk is
returned anyway with less than <code>n</code> elements. If <code>pad</code> is not
passed at all or is nil, then the partial chunk is discarded
from the result.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.chunks([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]
iex&gt; Enum.chunks([1, 2, 3, 4, 5, 6], 3, 2)
[[1, 2, 3], [3, 4, 5]]
iex&gt; Enum.chunks([1, 2, 3, 4, 5, 6], 3, 2, [7])
[[1, 2, 3], [3, 4, 5], [5, 6, 7]]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1330" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="chunks_by/2">
    <strong>chunks_by(coll, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>chunks_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: [[]]</li>
      
    </ul>
  
  <div class="docstring"><p>Splits <code>coll</code> on every element for which <code>fun</code> returns a new value.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.chunks_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))
[[1], [2, 2], [3], [4, 4, 6], [7, 7]]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1357" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="concat/1">
    <strong>concat(enumerables)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>concat(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Given an enumerable of enumerables, concatenate the enumerables into a single list.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.concat([1..3, 4..6, 7..9])
[1,2,3,4,5,6,7,8,9]

iex&gt; Enum.concat([[1, [2], 3], [4], [5, 6]])
[1,[2],3,4,5,6]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L252" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="concat/2">
    <strong>concat(left, right)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>concat(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Concatenates the enumerable on the right with the enumerable on the left.</p>

<p>This function produces the same result the <code>++</code> operator for lists.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.concat(1..3, 4..6)
[1,2,3,4,5,6]

iex&gt; Enum.concat([1, 2, 3], [4, 5, 6])
[1,2,3,4,5,6]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L271" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="count/1">
    <strong>count(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>count(<a href="#t:t/0">t</a>) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the collection&#39;s size.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.count([1, 2, 3])
3
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L118" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="count/2">
    <strong>count(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>count(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the count of items in the collection for which
<code>fun</code> returns <code>true</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.count([1, 2, 3, 4, 5], fn(x) -&gt; rem(x, 2) == 0 end)
2
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L132" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="drop/2">
    <strong>drop(collection, count)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>drop(<a href="#t:t/0">t</a>, integer) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Drops the first <code>count</code> items from <code>collection</code>.</p>

<p>A negative value <code>count</code> can be given, which means
the collection is enumerated once to retrieve the
proper index and the remaining of the calculation
is done from the end.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.drop([1, 2, 3], 2)
[3]
iex&gt; Enum.drop([1, 2, 3], 10)
[]
iex&gt; Enum.drop([1, 2, 3], 0)
[1,2,3]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L304" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="drop_while/2">
    <strong>drop_while(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>drop_while(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Drops items at the beginning of <code>collection</code> while <code>fun</code> returns <code>true</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.drop_while([1, 2, 3, 4, 5], fn(x) -&gt; x &lt; 3 end)
[3,4,5]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L329" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="each/2">
    <strong>each(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>each(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: :ok</li>
      
    </ul>
  
  <div class="docstring"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code>.
Returns <code>:ok</code>.</p>

<h2>Examples</h2>

<pre><code>Enum.each([&quot;some&quot;, &quot;example&quot;], fn(x) -&gt; IO.puts x end)
&quot;some&quot;
&quot;example&quot;
#=&gt; :ok
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L353" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="empty?/1">
    <strong>empty?(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>empty?(<a href="#t:t/0">t</a>) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if the collection is empty, otherwise <code>false</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.empty?([])
true
iex&gt; Enum.empty?([1, 2, 3])
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L378" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="fetch/2">
    <strong>fetch(collection, n)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>fetch(<a href="#t:t/0">t</a>, integer) :: {:ok, <a href="#t:element/0">element</a>} | :error</li>
      
    </ul>
  
  <div class="docstring"><p>Finds the element at the given index (zero-based).
Returns <code>{ :ok, element }</code> if found, otherwise <code>:error</code>.</p>

<p>A negative index can be passed, which means the collection is
iterated once and the index is counted from the end (i.e.
<code>-1</code> fetches the last element).</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.fetch([2, 4, 6], 0)
{ :ok, 2 }
iex&gt; Enum.fetch([2, 4, 6], 2)
{ :ok, 6 }
iex&gt; Enum.fetch([2, 4, 6], 4)
:error
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L407" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="fetch!/2">
    <strong>fetch!(collection, n)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>fetch!(<a href="#t:t/0">t</a>, integer) :: <a href="#t:element/0">element</a> | no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Finds the element at the given index (zero-based).
Raises <code>OutOfBoundsError</code> if the given position
is outside the range of the collection.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.fetch!([2, 4, 6], 0)
2

iex&gt; Enum.fetch!([2, 4, 6], 2)
6

iex&gt; Enum.fetch!([2, 4, 6], 4)
** (Enum.OutOfBoundsError) out of bounds error
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L447" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="filter/2">
    <strong>filter(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>filter(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Filters the collection, i.e. returns only those elements
for which <code>fun</code> returns <code>true</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.filter([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
[2]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L465" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="filter_map/3">
    <strong>filter_map(collection, filter, mapper)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>filter_map(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term)), (<a href="#t:element/0">element</a> -> <a href="#t:element/0">element</a>)) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Filters the collection and maps its values in one pass.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.filter_map([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end, &amp;(&amp;1 * 2))
[4]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L485" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="find/3">
    <strong>find(collection, ifnone // nil, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>find(<a href="#t:t/0">t</a>, <a href="#t:default/0">default</a>, (<a href="#t:element/0">element</a> -> any)) :: <a href="#t:element/0">element</a> | <a href="#t:default/0">default</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns the first item for which <code>fun</code> returns a truthy value. If no such
item is found, returns <code>ifnone</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.find([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find([2, 4, 6], 0, fn(x) -&gt; rem(x, 2) == 1 end)
0

iex&gt; Enum.find([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
3
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L514" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="find_index/2">
    <strong>find_index(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>find_index(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: <a href="#t:index/0">index</a> | nil</li>
      
    </ul>
  
  <div class="docstring"><p>Similar to <a href="#find/3"><code>find/3</code></a>, but returns the index (zero-based)
of the element instead of the element itself.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.find_index([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_index([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L573" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="find_value/3">
    <strong>find_value(collection, ifnone // nil, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>find_value(<a href="#t:t/0">t</a>, any, (<a href="#t:element/0">element</a> -> any)) :: any | nil</li>
      
    </ul>
  
  <div class="docstring"><p>Similar to <a href="#find/3"><code>find/3</code></a>, but returns the value of the function
invocation instead of the element itself.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.find_value([2, 4, 6], fn(x) -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_value([2, 3, 4], fn(x) -&gt; rem(x, 2) == 1 end)
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L544" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="first/1">
    <strong>first(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>first(<a href="#t:t/0">t</a>) :: nil | <a href="#t:element/0">element</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns the first item in the collection or <code>nil</code> otherwise.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.first([])
nil
iex&gt; Enum.first([1, 2, 3])
1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L598" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="flat_map/2">
    <strong>flat_map(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>flat_map(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a new collection appending the result of invoking <code>fun</code>
on each corresponding item of <code>collection</code>.</p>

<p>Given function should return a list.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.flat_map([:a, :b, :c], fn(x) -&gt; [x, x] end)
[:a, :a, :b, :b, :c, :c]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L622" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="join/2">
    <strong>join(collection, joiner // &quot;&quot;)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>join(<a href="#t:t/0">t</a>, <a href="String.html#t:t/0">String.t</a>) :: <a href="String.html#t:t/0">String.t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Joins the given <code>collection</code> according to <code>joiner</code>.
<code>joiner</code> can be either a binary or a list and the
result will be of the same type as <code>joiner</code>. If
<code>joiner</code> is not passed at all, it defaults to an
empty binary.</p>

<p>All items in the collection must be convertible
to a binary, otherwise an error is raised.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.join([1, 2, 3])
&quot;123&quot;
iex&gt; Enum.join([1, 2, 3], &quot; = &quot;)
&quot;1 = 2 = 3&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L654" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="map/2">
    <strong>map(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>map(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a new collection, where each item is the result
of invoking <code>fun</code> on each corresponding item of <code>collection</code>.</p>

<p>For dicts, the function accepts a key-value tuple.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.map([a: 1, b: 2], fn({k, v}) -&gt; { k, -v } end)
[a: -1, b: -2]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L679" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="map_join/3">
    <strong>map_join(collection, joiner // &quot;&quot;, mapper)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>map_join(<a href="#t:t/0">t</a>, <a href="String.html#t:t/0">String.t</a>, (<a href="#t:element/0">element</a> -> any)) :: <a href="String.html#t:t/0">String.t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Maps and joins the given <code>collection</code> in one pass.
<code>joiner</code> can be either a binary or a list and the
result will be of the same type as <code>joiner</code>. If
<code>joiner</code> is not passed at all, it defaults to an
empty binary.</p>

<p>All items in the collection must be convertible
to a binary, otherwise an error is raised.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.map_join([1, 2, 3], &amp;(&amp;1 * 2))
&quot;246&quot;
iex&gt; Enum.map_join([1, 2, 3], &quot; = &quot;, &amp;(&amp;1 * 2))
&quot;2 = 4 = 6&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L709" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="map_reduce/3">
    <strong>map_reduce(collection, acc, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>map_reduce(<a href="#t:t/0">t</a>, any, (<a href="#t:element/0">element</a>, any -> any)) :: any</li>
      
    </ul>
  
  <div class="docstring"><p>Invokes the given <code>fun</code> for each item in the <code>collection</code>
while also keeping an accumulator. Returns a tuple where
the first element is the mapped collection and the second
one is the final accumulator.</p>

<p>For dicts, the first tuple element must be a <code>{ key, value }</code>
tuple.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -&gt; { x * 2, x + acc } end)
{ [2, 4, 6], 6 }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L734" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="max/1">
    <strong>max(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>max(<a href="#t:t/0">t</a>) :: <a href="#t:element/0">element</a> | no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the maximum value.
Raises <code>EmptyError</code> if the collection is empty.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.max([1, 2, 3])
3
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1186" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="max_by/2">
    <strong>max_by(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>max_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: <a href="#t:element/0">element</a> | no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the maximum value as calculated by the given function.
Raises <code>EmptyError</code> if the collection is empty.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.max_by([&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;], fn(x) -&gt; String.length(x) end)
&quot;aaa&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1201" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="member?/2">
    <strong>member?(collection, value)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>member?(<a href="#t:t/0">t</a>, <a href="#t:element/0">element</a>) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Checks if <code>value</code> exists within the <code>collection</code>.</p>

<p>Membership is tested with the match (<code>===</code>) operator although
enumerables like ranges may include floats inside the given
range.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.member?(1..10, 5)
true
iex&gt; Enum.member?([:a, :b, :c], :d)
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L104" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="min/1">
    <strong>min(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>min(<a href="#t:t/0">t</a>) :: <a href="#t:element/0">element</a> | no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the minimum value.
Raises <code>EmptyError</code> if the collection is empty.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.min([1, 2, 3])
1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1240" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="min_by/2">
    <strong>min_by(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>min_by(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: <a href="#t:element/0">element</a> | no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the minimum value as calculated by the given function.
Raises <code>EmptyError</code> if the collection is empty.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.min_by([&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;], fn(x) -&gt; String.length(x) end)
&quot;a&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1255" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="partition/2">
    <strong>partition(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>partition(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> any)) :: {[], []}</li>
      
    </ul>
  
  <div class="docstring"><p>Partitions <code>collection</code> into two collections, where the first one contains elements
for which <code>fun</code> returns a truthy value, and the second one -- for which <code>fun</code>
returns <code>false</code> or <code>nil</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.partition([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
{ [2], [1,3] }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L754" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="reduce/2">
    <strong>reduce(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>reduce(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a>, any -> any)) :: any</li>
      
    </ul>
  
  <div class="docstring"><p>Invokes <code>fun</code> for each element in the collection passing that element and the
accumulator <code>acc</code> as arguments. <code>fun</code>&#39;s return value is stored in <code>acc</code>.
The first element of the collection is used as the initial value of <code>acc</code>.
Returns the accumulator.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.reduce([1, 2, 3, 4], fn(x, acc) -&gt; x * acc end)
24
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L795" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="reduce/3">
    <strong>reduce(collection, acc, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>reduce(<a href="#t:t/0">t</a>, any, (<a href="#t:element/0">element</a>, any -> any)) :: any</li>
      
    </ul>
  
  <div class="docstring"><p>Invokes <code>fun</code> for each element in the collection passing that element and the
accumulator <code>acc</code> as arguments. <code>fun</code>&#39;s return value is stored in <code>acc</code>.
Returns the accumulator.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.reduce([1, 2, 3], 0, fn(x, acc) -&gt; x + acc end)
6
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L778" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="reject/2">
    <strong>reject(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>reject(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns elements of collection for which <code>fun</code> returns <code>false</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.reject([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end)
[1, 3]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L825" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="reverse/1">
    <strong>reverse(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>reverse(<a href="#t:t/0">t</a>) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Reverses the collection.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.reverse([1, 2, 3])
[3, 2, 1]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L845" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="shuffle/1">
    <strong>shuffle(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>shuffle(<a href="#t:t/0">t</a>) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a list of collection elements shuffled.</p>

<p>Notice you need to explicitly call <code>:random.seed/1</code> and
set a seed value for the random algorithm. Otherwise, the
default seed will be set which will always return the same
result. For example, one could the following to set a seed
dynamically:</p>

<pre><code>:random.seed(:erlang.now)
</code></pre>

<h2>Examples</h2>

<pre><code>iex(1)&gt; Enum.shuffle([1, 2, 3])
[3, 2, 1]
iex(2)&gt; Enum.shuffle([1, 2, 3])
[3, 1, 2]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L875" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="slice/2">
    <strong>slice(coll, arg2)</strong>
  </p>
  
  <div class="docstring"><p>Returns a subset list of the given collection. Dropping elements
until element position <code>range.first</code>, then taking elements until element
position <code>range.last</code> (inclusive).</p>

<p>Positions are calculated by adding the number of items in the collection to
negative positions (so position -3 in a collection with count 5 becomes
position 2).</p>

<p>The first position (after adding count to negative positions) must be smaller
or equal to the last position.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.slice(1..100, 5..10)
[6, 7, 8, 9, 10, 11]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1440" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="slice/3">
    <strong>slice(coll, start, count)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>slice(<a href="#t:t/0">t</a>, integer, non_neg_integer) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a subset list of the given collection. Dropping elements
until element position <code>start</code>, then taking <code>count</code> elements.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.slice(1..100, 5, 10)
[6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1389" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sort/1">
    <strong>sort(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>sort(<a href="#t:t/0">t</a>) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a sorted list of collection elements. Uses the merge sort algorithm.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.sort([3, 2, 1])
[1,2,3]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L892" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sort/2">
    <strong>sort(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>sort(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a>, <a href="#t:element/0">element</a> -> boolean)) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a sorted list of collection elements. Uses the merge sort algorithm.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.sort([1, 2, 3], &amp;(&amp;1 &gt; &amp;2))
[3,2,1]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L912" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="split/2">
    <strong>split(collection, count)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>split(<a href="#t:t/0">t</a>, integer) :: {[], []}</li>
      
    </ul>
  
  <div class="docstring"><p>Splits the enumerable into two collections, leaving <code>count</code>
elements in the first one. If <code>count</code> is a negative number,
it starts counting from the back to the beginning of the
collection.</p>

<p>Be aware that a negative <code>count</code> implies the collection
will be iterated twice. Once to calculate the position and
a second time to do the actual splitting.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.split([1, 2, 3], 2)
{ [1,2], [3] }
iex&gt; Enum.split([1, 2, 3], 10)
{ [1,2,3], [] }
iex&gt; Enum.split([1, 2, 3], 0)
{ [], [1,2,3] }
iex&gt; Enum.split([1, 2, 3], -1)
{ [1,2], [3] }
iex&gt; Enum.split([1, 2, 3], -5)
{ [], [1,2,3] }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L946" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="split_while/2">
    <strong>split_while(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>split_while(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: {[], []}</li>
      
    </ul>
  
  <div class="docstring"><p>Splits <code>collection</code> in two while <code>fun</code> returns <code>true</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.split_while([1, 2, 3, 4], fn(x) -&gt; x &lt; 3 end)
{ [1, 2], [3, 4] }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L976" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="take/2">
    <strong>take(collection, count)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>take(<a href="#t:t/0">t</a>, integer) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Takes the first <code>count</code> items from the collection.</p>

<p>A negative value <code>count</code> can be passed, which means
the collection is enumerated once to retrieve the
proper index and the remaining of the calculation
is done from the end.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.take([1, 2, 3], 2)
[1,2]
iex&gt; Enum.take([1, 2, 3], 10)
[1,2,3]
iex&gt; Enum.take([1, 2, 3], 0)
[]
iex&gt; Enum.take([1, 2, 3], -1)
[1,2]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1013" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="take_every/2">
    <strong>take_every(collection, nth)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>take_every(<a href="#t:t/0">t</a>, integer) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a collection of every <code>nth</code> items in the collection,
starting with the first.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.take_every(1..10, 2)
[1, 3, 5, 7, 9]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1049" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="take_while/2">
    <strong>take_while(collection, fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>take_while(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> as_boolean(term))) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Takes the items at the beginning of <code>collection</code> while <code>fun</code> returns <code>true</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.take_while([1, 2, 3], fn(x) -&gt; x &lt; 3 end)
[1, 2]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1073" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="to_list/1">
    <strong>to_list(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>to_list(<a href="#t:t/0">t</a>) :: [term]</li>
      
    </ul>
  
  <div class="docstring"><p>Convert <code>collection</code> to a list.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.to_list(1 .. 3)
[1, 2, 3]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1099" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="uniq/2">
    <strong>uniq(collection, fun // fn x -&gt; x end)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>uniq(<a href="#t:t/0">t</a>, (<a href="#t:element/0">element</a> -> term)) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Iterates the enumerable removing all duplicated items.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.uniq([1, 2, 3, 2, 1])
[1, 2, 3]

iex&gt; Enum.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end)
[{1,:x}, {2,:y}]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1123" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="with_index/1">
    <strong>with_index(collection)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>with_index(<a href="#t:t/0">t</a>) :: [{<a href="#t:element/0">element</a>, non_neg_integer}]</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the collection with each element wrapped in a tuple
along side its index.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.with_index [1,2,3]
[{1,0},{2,1},{3,2}]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1294" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="zip/2">
    <strong>zip(coll1, coll2)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>zip(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: [{any, any}]</li>
      
    </ul>
  
  <div class="docstring"><p>Zips corresponding elements from two collections into one list
of tuples. The number of elements in the resulting list is
dictated by the first enum. If the second list is shorter,
values are filled with <code>nil</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Enum.zip([1, 2, 3], [:a, :b, :c])
[{1,:a},{2,:b},{3,:c}]

iex&gt; Enum.zip([1,2,3,4,5], [:a, :b, :c])
[{1,:a},{2,:b},{3,:c},{4,nil},{5,nil}]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.2/lib/elixir/lib/enum.ex#L1158" target="_blank" class="view_source">Source</a>
  
</div>

        </div>
      

      

      
    </div>
  </body>
</html>
