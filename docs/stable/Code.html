<!DOCTYPE html>
<html>
  <head>
    <title>Code</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        Code
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>The Code module is responsible for managing code compilation,
code evaluation and code loading.</p>

<p>It complements <a href="http://www.erlang.org/doc/man/code.html">Erlang&#39;s code module</a>
to add behavior which is specific to Elixir.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L1" target="_blank" class="view_source">Source</a>

      

      
        <h2 id="functions_summary">Functions summary</h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#append_path/1">append_path(path)</a></td>
  
    <td class="summary_synopsis"><p>Appends a path to the Erlang VM code path.
The path is expanded with <a href="Path.html#expand/1"><code>Path.expand/1</code></a> before being appended.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#compile_quoted/2">compile_quoted(quoted, file // &quot;nofile&quot;)</a></td>
  
    <td class="summary_synopsis"><p>Compiles the quoted expression and returns a list of tuples where
the first element is the module name and the second one is its
binary.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#compile_string/2">compile_string(string, file // &quot;nofile&quot;)</a></td>
  
    <td class="summary_synopsis"><p>Compiles the given string and returns a list of tuples where
the first element is the module name and the second one is its
binary.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#compiler_options/0">compiler_options()</a></td>
  
    <td class="summary_synopsis"><p>Loads the compilation options from the code server.
Check <a href="#compiler_options/1"><code>compiler_options/1</code></a> for more information.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#compiler_options/1">compiler_options(opts)</a></td>
  
    <td class="summary_synopsis"><p>Sets compilation options. These options are global
since they are stored by Elixir&#39;s Code Server.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#delete_path/1">delete_path(path)</a></td>
  
    <td class="summary_synopsis"><p>Deletes a path from the Erlang VM code path.
The path is expanded with <a href="Path.html#expand/1"><code>Path.expand/1</code></a> before being deleted.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#ensure_compiled/1">ensure_compiled(module)</a></td>
  
    <td class="summary_synopsis"><p>Ensures the given module is compiled and loaded. If the module
is already loaded, it works as no-op. If the module was not
loaded yet, it checks if it needs to be compiled first and 
then tries to load it.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#ensure_compiled?/1">ensure_compiled?(module)</a></td>
  
    <td class="summary_synopsis"><p>Similar to <a href="#ensure_compiled/1"><code>ensure_compiled/1</code></a>, but returns a boolean in case
it could be ensured or not.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#ensure_loaded/1">ensure_loaded(module)</a></td>
  
    <td class="summary_synopsis"><p>Ensures the given module is loaded. If the module is already
loaded, it works as no-op. If the module was not yet loaded,
it tries to load it.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#ensure_loaded?/1">ensure_loaded?(module)</a></td>
  
    <td class="summary_synopsis"><p>Similar to <a href="#ensure_loaded/1"><code>ensure_loaded/1</code></a>, but returns a boolean in case
it could be ensured or not.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#eval_quoted/3">eval_quoted(quoted, binding // [], opts // [])</a></td>
  
    <td class="summary_synopsis"><p>Evaluates the quoted contents.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#eval_string/3">eval_string(string, binding // [], opts // [])</a></td>
  
    <td class="summary_synopsis"><p>Evaluates the contents given by <code>string</code>. The second argument is 
a keyword list of variable bindings, followed by a keyword list of
environment options. Those options can be:</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#load_file/2">load_file(file, relative_to // nil)</a></td>
  
    <td class="summary_synopsis"><p>Loads the given <code>file</code>. Accepts <code>relative_to</code> as an argument to tell where
the file is located. If the file was already required/loaded, loads it again.
It returns a list of tuples <code>{ ModuleName, &lt;&lt;byte_code&gt;&gt; }</code>, one tuple for each
module defined in the file.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#loaded_files/0">loaded_files()</a></td>
  
    <td class="summary_synopsis"><p>Returns all loaded files.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#prepend_path/1">prepend_path(path)</a></td>
  
    <td class="summary_synopsis"><p>Prepends a path to the Erlang VM code path.
The path is expanded with <a href="Path.html#expand/1"><code>Path.expand/1</code></a> before being prepended.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#require_file/2">require_file(file, relative_to // nil)</a></td>
  
    <td class="summary_synopsis"><p>Requires the given <code>file</code>. Accepts <code>relative_to</code> as an argument to tell where
the file is located. The return value is the same as that of <a href="#load_file/2"><code>load_file/2</code></a>. If
the file was already required/loaded, doesn&#39;t do anything and returns nil.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#string_to_quoted/2">string_to_quoted(string, opts // [])</a></td>
  
    <td class="summary_synopsis"><p>Converts the given string to its quoted form. Returns <code>{ :ok, quoted_form }</code>
if it succeeds, <code>{ :error, { line, error, token } }</code> otherwise.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#string_to_quoted!/2">string_to_quoted!(string, opts // [])</a></td>
  
    <td class="summary_synopsis"><p>Converts the given string to its quoted form. It returns the ast if it succeeds,
raises an exception otherwise. The exception is a <code>TokenMissingError</code>
in case a token is missing (usually because the expression is incomplete),
<code>SyntaxError</code> otherwise.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#unload_files/1">unload_files(files)</a></td>
  
    <td class="summary_synopsis"><p>Removes the given files from the loaded files list.
The modules defined in the file are not removed,
calling this function only removes them from the list,
allowing them to be required again.</p>
</td>
  
</tr>

        </table>
      

      

      

      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="append_path/1">
    <strong>append_path(path)</strong>
  </p>
  
  <div class="docstring"><p>Appends a path to the Erlang VM code path.
The path is expanded with <a href="Path.html#expand/1"><code>Path.expand/1</code></a> before being appended.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L38" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="compile_quoted/2">
    <strong>compile_quoted(quoted, file // &quot;nofile&quot;)</strong>
  </p>
  
  <div class="docstring"><p>Compiles the quoted expression and returns a list of tuples where
the first element is the module name and the second one is its
binary.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L343" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="compile_string/2">
    <strong>compile_string(string, file // &quot;nofile&quot;)</strong>
  </p>
  
  <div class="docstring"><p>Compiles the given string and returns a list of tuples where
the first element is the module name and the second one is its
binary.</p>

<p>For compiling many files at once, check <a href="Kernel.ParallelCompiler.html#files/2"><code>Kernel.ParallelCompiler.files/2</code></a>.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L334" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="compiler_options/0">
    <strong>compiler_options()</strong>
  </p>
  
  <div class="docstring"><p>Loads the compilation options from the code server.
Check <a href="#compiler_options/1"><code>compiler_options/1</code></a> for more information.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L300" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="compiler_options/1">
    <strong>compiler_options(opts)</strong>
  </p>
  
  <div class="docstring"><p>Sets compilation options. These options are global
since they are stored by Elixir&#39;s Code Server.</p>

<p>Available options are:</p>

<ul>
<li><p><code>:docs</code> - when <code>true</code>, retain documentation in the compiled module,
<code>true</code> by default;</p></li>
<li><p><code>:debug_info</code> - when <code>true</code>, retain debug information in the compiled module.
This allows a developer to reconstruct the original source
code, for such reasons, <code>false</code> by default;</p></li>
<li><p><code>:ignore_module_conflict</code> - when <code>true</code>, override modules that were already defined
without raising errors, <code>false</code> by default;</p></li>
<li><p><code>:warnings_as_errors</code> - cause compilation to fail when warnings are generated;</p></li>
</ul>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L323" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="delete_path/1">
    <strong>delete_path(path)</strong>
  </p>
  
  <div class="docstring"><p>Deletes a path from the Erlang VM code path.
The path is expanded with <a href="Path.html#expand/1"><code>Path.expand/1</code></a> before being deleted.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L54" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="ensure_compiled/1">
    <strong>ensure_compiled(module)</strong>
  </p>
  
  <div class="docstring"><p>Ensures the given module is compiled and loaded. If the module
is already loaded, it works as no-op. If the module was not
loaded yet, it checks if it needs to be compiled first and 
then tries to load it.</p>

<p>If it succeeds loading the module, it returns
<code>{ :module, module }</code>. If not, returns <code>{ :error, reason }</code> with
the error reason.</p>

<p>Check <a href="#ensure_loaded/1"><code>ensure_loaded/1</code></a> for more information on module loading
and when to use <a href="#ensure_loaded/1"><code>ensure_loaded/1</code></a> or <a href="#ensure_compiled/1"><code>ensure_compiled/1</code></a>.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L410" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="ensure_compiled?/1">
    <strong>ensure_compiled?(module)</strong>
  </p>
  
  <div class="docstring"><p>Similar to <a href="#ensure_compiled/1"><code>ensure_compiled/1</code></a>, but returns a boolean in case
it could be ensured or not.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L431" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="ensure_loaded/1">
    <strong>ensure_loaded(module)</strong>
  </p>
  
  <div class="docstring"><p>Ensures the given module is loaded. If the module is already
loaded, it works as no-op. If the module was not yet loaded,
it tries to load it.</p>

<p>If it succeeds loading the module, it returns
<code>{ :module, module }</code>. If not, returns <code>{ :error, reason }</code> with
the error reason.</p>

<h2>Code loading on the Erlang VM</h2>

<p>Erlang has two modes to load code: interactive and embedded.</p>

<p>By default, the Erlang VM runs in interactive mode, where modules
are loaded as needed. In embedded mode the opposite happens, as all
modules need to be loaded upfront or explicitly.</p>

<p>Therefore, this function is used to check if a module is loaded
before using it and allows one to react accordingly. For example, the <code>URI</code> 
module uses this function to check if a specific parser exists for a given
URI scheme.</p>

<h2>Code.ensure_compiled</h2>

<p>Elixir also contains an <a href="#ensure_compiled/1"><code>ensure_compiled/1</code></a> function that is a
superset of <a href="#ensure_loaded/1"><code>ensure_loaded/1</code></a>.</p>

<p>Since Elixir&#39;s compilation happens in parallel, in some situations
you may need to use a module but that was not yet compiled, therefore
it can&#39;t even be loaded.</p>

<p><a href="#ensure_compiled/1"><code>ensure_compiled/1</code></a> halts the current process until the
module we are depending on is available.</p>

<p>In most cases, <code>ensure_loaded</code> is enough. <code>ensure_compiled</code>
must be used in some rare cases, usually involving macros
that need to invoke a module for callback information.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L385" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="ensure_loaded?/1">
    <strong>ensure_loaded?(module)</strong>
  </p>
  
  <div class="docstring"><p>Similar to <a href="#ensure_loaded/1"><code>ensure_loaded/1</code></a>, but returns a boolean in case
it could be ensured or not.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L393" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="eval_quoted/3">
    <strong>eval_quoted(quoted, binding // [], opts // [])</strong>
  </p>
  
  <div class="docstring"><p>Evaluates the quoted contents.</p>

<p>See <a href="#eval_string/3"><code>eval_string/3</code></a> for a description of arguments and return values.</p>

<h2>Examples</h2>

<pre><code>iex&gt; contents = quote(hygiene: [vars: false], do: a + b)
...&gt; Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
{3, [a: 1, b: 2]}
</code></pre>

<p>For convenience, you can pass <code>__ENV__</code> as the <code>opts</code> argument and
all options will be automatically extracted from the current environment:</p>

<pre><code>iex&gt; contents = quote(hygiene: [vars: false], do: a + b)
...&gt; Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L144" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="eval_string/3">
    <strong>eval_string(string, binding // [], opts // [])</strong>
  </p>
  
  <div class="docstring"><p>Evaluates the contents given by <code>string</code>. The second argument is 
a keyword list of variable bindings, followed by a keyword list of
environment options. Those options can be:</p>

<ul>
<li><code>:file</code> - the file to be considered in the evaluation</li>
<li><code>:line</code> - the line on which the script starts</li>
<li><code>:delegate_locals_to</code> - delegate local calls to the given module,
the default is to not delegate</li>
</ul>

<p>Additionally, the following scope values can be configured:</p>

<ul>
<li><code>:aliases</code> - a list of tuples with the alias and its target</li>
<li><code>:requires</code> - a list of modules required</li>
<li><code>:functions</code> - a list of tuples where the first element is a module
and the second a list of imported function names and arity. The list
of function names and arity must be sorted</li>
<li><code>:macros</code> - a list of tuples where the first element is a module
and the second a list of imported macro names and arity. The list
of function names and arity must be sorted</li>
</ul>

<p>Notice that setting any of the values above overrides Elixir&#39;s default
values. For example, setting <code>:requires</code> to <code>[]</code>, will no longer
automatically require the <code>Kernel</code> module; in the same way setting
<code>:macros</code> will no longer auto-import <code>Kernel</code> macros like <code>if</code>, <code>case</code>,
etc.</p>

<p>Returns a tuple of the form <code>{ value, binding }</code>,
where <code>value</code> is the the value returned from evaluating <code>string</code>; <code>binding</code>
is a keyword list with the value of all variable bindings after evaluating
<code>string</code>. If an error occurs while evaluating <code>string</code> an exception will be raised.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Code.eval_string(&quot;a + b&quot;, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
{3, [a: 1, b: 2]}

iex&gt; Code.eval_string(&quot;c = a + b&quot;, [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2, c: 3]}

iex&gt; Code.eval_string(&quot;a = a + b&quot;, [a: 1, b: 2])          
{3, [a: 3, b: 2]}
</code></pre>

<p>For convenience, you can pass <code>__ENV__</code> as the <code>opts</code> argument and
all imports, requires and aliases defined in the current environment
will be automatically carried over:</p>

<pre><code>iex&gt; Code.eval_string(&quot;a + b&quot;, [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L109" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="load_file/2">
    <strong>load_file(file, relative_to // nil)</strong>
  </p>
  
  <div class="docstring"><p>Loads the given <code>file</code>. Accepts <code>relative_to</code> as an argument to tell where
the file is located. If the file was already required/loaded, loads it again.
It returns a list of tuples <code>{ ModuleName, &lt;&lt;byte_code&gt;&gt; }</code>, one tuple for each
module defined in the file.</p>

<p>Notice that if <code>load_file</code> is invoked by different processes
concurrently, the target file will be invoked concurrently
many times. I.e. if <code>load_file</code> is called N times with
a given file, the given file will be loaded N times. Check
<a href="#require_file/2"><code>require_file/2</code></a> if you don&#39;t want a file to be loaded concurrently.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L260" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="loaded_files/0">
    <strong>loaded_files()</strong>
  </p>
  
  <div class="docstring"><p>Returns all loaded files.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L20" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="prepend_path/1">
    <strong>prepend_path(path)</strong>
  </p>
  
  <div class="docstring"><p>Prepends a path to the Erlang VM code path.
The path is expanded with <a href="Path.html#expand/1"><code>Path.expand/1</code></a> before being prepended.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L46" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="require_file/2">
    <strong>require_file(file, relative_to // nil)</strong>
  </p>
  
  <div class="docstring"><p>Requires the given <code>file</code>. Accepts <code>relative_to</code> as an argument to tell where
the file is located. The return value is the same as that of <a href="#load_file/2"><code>load_file/2</code></a>. If
the file was already required/loaded, doesn&#39;t do anything and returns nil.</p>

<p>Notice that if <code>require_file</code> is invoked by different processes concurrently,
the first process to invoke <code>require_file</code> acquires a lock and the remaining
ones will block until the file is available. I.e. if <code>require_file</code> is called
N times with a given file, it will be loaded only once. The first process to
call <code>require_file</code> will get the list of loaded modules, others will get <code>nil</code>.</p>

<p>Check <a href="#load_file/2"><code>load_file/2</code></a> if you want a file to be loaded concurrently.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L281" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="string_to_quoted/2">
    <strong>string_to_quoted(string, opts // [])</strong>
  </p>
  
  <div class="docstring"><p>Converts the given string to its quoted form. Returns <code>{ :ok, quoted_form }</code>
if it succeeds, <code>{ :error, { line, error, token } }</code> otherwise.</p>

<h2>Options</h2>

<ul>
<li><p><code>:file</code> - The filename to be used in stacktraces
and the file reported in the <code>__ENV__</code> variable.</p></li>
<li><p><code>:line</code> - The line reported in the <code>__ENV__</code> variable.</p></li>
<li><p><code>:existing_atoms_only</code> - When <code>true</code>, raises an error
when non-existing atoms are found by the tokenizer.</p></li>
</ul>

<h2>Macro.to_string/1</h2>

<p>The opposite of converting a string to its quoted form is
<code>Macro.to_string/1</code>, which converts a quoted form to a string/binary
representation.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L218" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="string_to_quoted!/2">
    <strong>string_to_quoted!(string, opts // [])</strong>
  </p>
  
  <div class="docstring"><p>Converts the given string to its quoted form. It returns the ast if it succeeds,
raises an exception otherwise. The exception is a <code>TokenMissingError</code>
in case a token is missing (usually because the expression is incomplete),
<code>SyntaxError</code> otherwise.</p>

<p>Check <a href="#string_to_quoted/2"><code>string_to_quoted/2</code></a> for options information.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L237" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="unload_files/1">
    <strong>unload_files(files)</strong>
  </p>
  
  <div class="docstring"><p>Removes the given files from the loaded files list.
The modules defined in the file are not removed,
calling this function only removes them from the list,
allowing them to be required again.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/6a770579105f7b58877ac1a0e0b039513a8e85fc/lib/elixir/lib/code.ex#L30" target="_blank" class="view_source">Source</a>
  
</div>

        </div>
      

      

      
    </div>
  </body>
</html>
