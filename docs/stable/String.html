<!DOCTYPE html>
<html>
  <head>
    <title>String</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        String
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>A String in Elixir is a UTF-8 encoded binary.</p>

<h2>String and binary operations</h2>

<p>The functions in this module act according to the
Unicode Standard, version 6.2.0. For example,
<a href="#capitalize/1"><code>capitalize/1</code></a>, <a href="#downcase/1"><code>downcase/1</code></a>, <a href="#strip/1"><code>strip/1</code></a> are provided by this
module.</p>

<p>In addition to this module, Elixir provides more low-level
operations that work directly with binaries. Some
of those can be found in the <code>Kernel</code> module, as:</p>

<ul>
<li><a href="Kernel.html#binary_part/3"><code>Kernel.binary_part/3</code></a> - retrieves part of the binary</li>
<li><a href="Kernel.html#bit_size/1"><code>Kernel.bit_size/1</code></a> and <a href="Kernel.html#byte_size/1"><code>Kernel.byte_size/1</code></a> - size related functions</li>
<li><a href="Kernel.html#is_bitstring/1"><code>Kernel.is_bitstring/1</code></a> and <a href="Kernel.html#is_binary/1"><code>Kernel.is_binary/1</code></a> - type checking function</li>
<li>Plus a number of conversion functions, like <a href="Kernel.html#binary_to_atom/1"><code>Kernel.binary_to_atom/1</code></a>,
<a href="Kernel.html#binary_to_integer/2"><code>Kernel.binary_to_integer/2</code></a>, <a href="Kernel.html#binary_to_term/1"><code>Kernel.binary_to_term/1</code></a> and their inverses,
like <a href="Kernel.html#integer_to_binary/2"><code>Kernel.integer_to_binary/2</code></a></li>
</ul>

<p>Finally, the <a href="http://erlang.org/doc/man/binary.html"><code>:binary</code> module</a>
provides a few other functions that work on the byte level.</p>

<h2>Codepoints and graphemes</h2>

<p>As per the Unicode Standard, a codepoint is an Unicode
Character, which may be represented by one or more bytes.
For example, the character &quot;é&quot; is represented with two
bytes:</p>

<pre><code>iex&gt; byte_size(&quot;é&quot;)
2
</code></pre>

<p>However, this module returns the proper length:</p>

<pre><code>iex&gt; String.length(&quot;é&quot;)
1
</code></pre>

<p>Furthermore, this module also presents the concept of
graphemes, which are multiple characters that may be
&quot;perceived as a single character&quot; by readers. For example,
the same &quot;é&quot; character written above could be represented
by the letter &quot;e&quot; followed by the accent ́:</p>

<pre><code>iex&gt; string = &quot;\x{0065}\x{0301}&quot;
...&gt; byte_size(string)
3
iex&gt; String.length(string)
1
</code></pre>

<p>Although the example above is made of two characters, it is
perceived by users as one.</p>

<p>Graphemes can also be two characters that are interpreted
as one by some languages. For example, some languages may
consider &quot;ch&quot; as a grapheme. However, since this information
depends on the locale, it is not taken into account by this
module.</p>

<p>In general, the functions in this module rely on the Unicode
Standard, but does not contain any of the locale specific
behaviour.</p>

<p>More information about graphemes can be found in the <a href="http://www.unicode.org/reports/tr29/">Unicode
Standard Annex #29</a>.
This current Elixir version implements Extended Grapheme Cluster
algorithm.</p>

<h2>Integer codepoints</h2>

<p>Although codepoints could be represented as integers, this
module represents all codepoints as strings. For example:</p>

<pre><code>iex&gt; String.codepoints(&quot;josé&quot;)
[&quot;j&quot;, &quot;o&quot;, &quot;s&quot;, &quot;é&quot;]
</code></pre>

<p>There are a couple of ways to retrieve a character integer
codepoint. One may use the <code>?</code> special macro:</p>

<pre><code>iex&gt; ?j
106
iex&gt; ?é
233
</code></pre>

<p>Or also via pattern matching:</p>

<pre><code>iex&gt; &lt;&lt; eacute :: utf8 &gt;&gt; = &quot;é&quot;
...&gt; eacute
233
</code></pre>

<p>As we have seen above, codepoints can be inserted into
a string by their hexadecimal code:</p>

<pre><code>&quot;jos\x{0065}\x{0301}&quot; #=&gt;
&quot;josé&quot;
</code></pre>

<h2>Self-synchronization</h2>

<p>The UTF-8 encoding is self-synchronizing. This means that
if malformed data (i.e., data that is not possible according
to the definition of the encoding) is encountered, only one
codepoint needs to be rejected.</p>

<p>This module relies on this behaviour to ignore such invalid
characters. For example, <a href="#length/1"><code>length/1</code></a> is going to return
a correct result even if an invalid codepoint is fed into it.</p>

<p>In other words, this module expects invalid data to be detected
when retrieving data from the external source. For example, a
driver that reads strings from a database will be the one
responsible to check the validity of the encoding.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L3" target="_blank" class="view_source">Source</a>

      

      
        <h2 id="functions_summary">Functions summary</h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#at/2">at(string, position)</a></td>
  
    <td class="summary_synopsis"><p>Returns the grapheme in the <code>position</code> of the given utf8 <code>string</code>.
If <code>position</code> is greater than <code>string</code> length, than it returns <code>nil</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#capitalize/1">capitalize(string)</a></td>
  
    <td class="summary_synopsis"><p>Converts the first character in the given string to
uppercase and the remaining to lowercase.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#codepoints/1">codepoints(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns all codepoints in the string.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#contains?/2">contains?(string, matches)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>string</code> contains match, otherwise <code>false</code>.
<code>matches</code> can be either a single string or a list of strings.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#downcase/1">downcase(binary)</a></td>
  
    <td class="summary_synopsis"><p>Convert all characters on the given string to lowercase.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#duplicate/2">duplicate(subject, n)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary <code>subject</code> duplicated <code>n</code> times.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#ends_with?/2">ends_with?(string, suffixes)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>string</code> ends with any of the suffixes given, otherwise
<code>false</code>. <code>suffixes</code> can be either a single suffix or a list of suffixes.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#first/1">first(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns the first grapheme from an utf8 string,
nil if the string is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#from_char_list/1">from_char_list(list)</a></td>
  
    <td class="summary_synopsis"><p>Converts a list of integer codepoints to a string.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#from_char_list!/1">from_char_list!(list)</a></td>
  
    <td class="summary_synopsis"><p>Converts a list of integer codepoints to a string.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#graphemes/1">graphemes(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns unicode graphemes in the string as per Extended Grapheme
Cluster algorithm outlined in the <a href="http://www.unicode.org/reports/tr29/">Unicode Standard Annex #29,
Unicode Text Segmentation</a>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#last/1">last(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns the last grapheme from an utf8 string,
<code>nil</code> if the string is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#length/1">length(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns the number of unicode graphemes in an utf8 string.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#ljust/2">ljust(subject, len)</a></td>
  
    <td class="summary_synopsis"><p>Returns a new string of length <code>len</code> with <code>subject</code> left justified and padded
with <code>padding</code>. If <code>padding</code> is not present, it defaults to whitespace. When
<code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is returned.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#ljust/3">ljust(subject, len, padding)</a></td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#lstrip/1">lstrip(binary)</a></td>
  
    <td class="summary_synopsis"><p>Returns a string where leading Unicode whitespace
has been removed.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#lstrip/2">lstrip(other, char)</a></td>
  
    <td class="summary_synopsis"><p>Returns a string where leading <code>char</code> have been removed.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#next_codepoint/1">next_codepoint(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns the next codepoint in a String.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#next_grapheme/1">next_grapheme(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns the next grapheme in a String.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#printable?/1">printable?(arg1)</a></td>
  
    <td class="summary_synopsis"><p>Checks if a string is printable considering it is encoded
as UTF-8. Returns <code>true</code> if so, <code>false</code> otherwise.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#replace/4">replace(subject, pattern, replacement, options // [])</a></td>
  
    <td class="summary_synopsis"><p>Returns a new binary based on <code>subject</code> by replacing the parts
matching <code>pattern</code> by <code>replacement</code>. By default, it replaces
all entries, except if the <code>global</code> option is set to <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#reverse/1">reverse(string)</a></td>
  
    <td class="summary_synopsis"><p>Reverses the given string. Works on graphemes.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#rjust/2">rjust(subject, len)</a></td>
  
    <td class="summary_synopsis"><p>Returns a new string of length <code>len</code> with <code>subject</code> right justified and
padded with <code>padding</code>. If <code>padding</code> is not present, it defaults to
whitespace. When <code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is
returned.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#rjust/3">rjust(subject, len, padding)</a></td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#rstrip/1">rstrip(binary)</a></td>
  
    <td class="summary_synopsis"><p>Returns a string where trailing Unicode whitespace
has been removed.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#rstrip/2">rstrip(string, char)</a></td>
  
    <td class="summary_synopsis"><p>Returns a string where trailing <code>char</code> have been removed.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#slice/2">slice(string, range)</a></td>
  
    <td class="summary_synopsis"><p>Returns a substring from the offset given by the start of the
range to the offset given by the end of the range.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#slice/3">slice(string, start, len)</a></td>
  
    <td class="summary_synopsis"><p>Returns a substring starting at the offset given by the first, and
a length given by the second.
If the offset is greater than string length, than it returns <code>nil</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#split/1">split(binary)</a></td>
  
    <td class="summary_synopsis"><p>Divides a string into substrings at each Unicode whitespace
occurrence with leading and trailing whitespace ignored.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#split/3">split(binary, pattern, options // [])</a></td>
  
    <td class="summary_synopsis"><p>Divides a string into substrings based on a pattern,
returning a list of these substrings. The pattern can
be a string, a list of strings or a regular expression.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#starts_with?/2">starts_with?(string, prefixes)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>string</code> starts with any of the prefixes given, otherwise
<code>false</code>. <code>prefixes</code> can be either a single prefix or a list of prefixes.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#strip/1">strip(string)</a></td>
  
    <td class="summary_synopsis"><p>Returns a string where leading/trailing Unicode whitespace
has been removed.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#strip/2">strip(string, char)</a></td>
  
    <td class="summary_synopsis"><p>Returns a string where leading/trailing <code>char</code> have been
removed.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#to_char_list/1">to_char_list(string)</a></td>
  
    <td class="summary_synopsis"><p>Converts a string into a char list converting each codepoint to its
respective integer value.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#to_char_list!/1">to_char_list!(string)</a></td>
  
    <td class="summary_synopsis"><p>Converts a string into a char list converting each codepoint to its
respective integer value.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#upcase/1">upcase(binary)</a></td>
  
    <td class="summary_synopsis"><p>Convert all characters on the given string to uppercase.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#valid?/1">valid?(arg1)</a></td>
  
    <td class="summary_synopsis"><p>Checks whether <code>str</code> contains only valid characters.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#valid_character?/1">valid_character?(codepoint)</a></td>
  
    <td class="summary_synopsis"><p>Checks whether <code>str</code> is a valid character.</p>
</td>
  
</tr>

        </table>
      

      

      

      
        <div id="types_details" class="details_list">
          <h2>Types</h2>
          <div class="type_detail">
  <p class="typespec" id="t:t/0">
    <a href="#t:t/0">t</a> :: binary
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:codepoint/0">
    <a href="#t:codepoint/0">codepoint</a> :: <a href="#t:t/0">t</a>
  </p>
  
</div>
<div class="type_detail">
  <p class="typespec" id="t:grapheme/0">
    <a href="#t:grapheme/0">grapheme</a> :: <a href="#t:t/0">t</a>
  </p>
  
</div>

        </div>
      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="at/2">
    <strong>at(string, position)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>at(<a href="#t:t/0">t</a>, integer) :: <a href="#t:grapheme/0">grapheme</a> | nil</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the grapheme in the <code>position</code> of the given utf8 <code>string</code>.
If <code>position</code> is greater than <code>string</code> length, than it returns <code>nil</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.at(&quot;elixir&quot;, 0)
&quot;e&quot;
iex&gt; String.at(&quot;elixir&quot;, 1)
&quot;l&quot;
iex&gt; String.at(&quot;elixir&quot;, 10)
nil
iex&gt; String.at(&quot;elixir&quot;, -1)
&quot;r&quot;
iex&gt; String.at(&quot;elixir&quot;, -10)
nil
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L794" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="capitalize/1">
    <strong>capitalize(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>capitalize(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Converts the first character in the given string to
uppercase and the remaining to lowercase.</p>

<p>This relies on the titlecase information provided
by the Unicode Standard. Note this function makes
no attempt to capitalize all words in the string
(usually known as titlecase).</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.capitalize(&quot;abcd&quot;)
&quot;Abcd&quot;
iex&gt; String.capitalize(&quot;ﬁn&quot;)
&quot;Fin&quot;
iex&gt; String.capitalize(&quot;josé&quot;)
&quot;José&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L294" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="codepoints/1">
    <strong>codepoints(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>codepoints(<a href="#t:t/0">t</a>) :: [<a href="#t:codepoint/0">codepoint</a>]</li>
      
    </ul>
  
  <div class="docstring"><p>Returns all codepoints in the string.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.codepoints(&quot;josé&quot;)
[&quot;j&quot;, &quot;o&quot;, &quot;s&quot;, &quot;é&quot;]
iex&gt; String.codepoints(&quot;оптими зации&quot;)
[&quot;о&quot;,&quot;п&quot;,&quot;т&quot;,&quot;и&quot;,&quot;м&quot;,&quot;и&quot;,&quot; &quot;,&quot;з&quot;,&quot;а&quot;,&quot;ц&quot;,&quot;и&quot;,&quot;и&quot;]
iex&gt; String.codepoints(&quot;ἅἪῼ&quot;)
[&quot;ἅ&quot;,&quot;Ἢ&quot;,&quot;ῼ&quot;]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L599" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="contains?/2">
    <strong>contains?(string, matches)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>contains?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>string</code> contains match, otherwise <code>false</code>.
<code>matches</code> can be either a single string or a list of strings.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.contains? &quot;elixir of life&quot;, &quot;of&quot;
true
iex&gt; String.contains? &quot;elixir of life&quot;, [&quot;life&quot;, &quot;death&quot;]
true
iex&gt; String.contains? &quot;elixir of life&quot;, [&quot;death&quot;, &quot;mercury&quot;]
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L1051" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="downcase/1">
    <strong>downcase(binary)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>downcase(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Convert all characters on the given string to lowercase.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.downcase(&quot;ABCD&quot;)
&quot;abcd&quot;
iex&gt; String.downcase(&quot;AB 123 XPTO&quot;)
&quot;ab 123 xpto&quot;
iex&gt; String.downcase(&quot;JOSÉ&quot;)
&quot;josé&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L272" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="duplicate/2">
    <strong>duplicate(subject, n)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>duplicate(<a href="#t:t/0">t</a>, pos_integer) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a binary <code>subject</code> duplicated <code>n</code> times.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.duplicate(&quot;abc&quot;, 0)
&quot;&quot;
iex&gt; String.duplicate(&quot;abc&quot;, 1)
&quot;abc&quot;
iex&gt; String.duplicate(&quot;abc&quot;, 2)
&quot;abcabc&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L581" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="ends_with?/2">
    <strong>ends_with?(string, suffixes)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>ends_with?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>string</code> ends with any of the suffixes given, otherwise
<code>false</code>. <code>suffixes</code> can be either a single suffix or a list of suffixes.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.ends_with? &quot;language&quot;, &quot;age&quot;
true
iex&gt; String.ends_with? &quot;language&quot;, [&quot;youth&quot;, &quot;age&quot;]
true
iex&gt; String.ends_with? &quot;language&quot;, [&quot;youth&quot;, &quot;elixir&quot;]
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L1012" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="first/1">
    <strong>first(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>first(<a href="#t:t/0">t</a>) :: <a href="#t:grapheme/0">grapheme</a> | nil</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the first grapheme from an utf8 string,
nil if the string is empty.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.first(&quot;elixir&quot;)
&quot;e&quot;
iex&gt; String.first(&quot;եոգլի&quot;)
&quot;ե&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L722" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="from_char_list/1">
    <strong>from_char_list(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>from_char_list(char_list) :: {:ok, <a href="String.html#t:t/0">String.t</a>} | {:error, binary, binary} | {:incomplete, binary, binary}</li>
      
    </ul>
  
  <div class="docstring"><p>Converts a list of integer codepoints to a string.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.from_char_list([0x00E6, 0x00DF])
{ :ok, &quot;æß&quot; }
iex&gt; String.from_char_list([0x0061, 0x0062, 0x0063])
{ :ok, &quot;abc&quot; }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L1152" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="from_char_list!/1">
    <strong>from_char_list!(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>from_char_list!(char_list) :: <a href="String.html#t:t/0">String.t</a> | no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Converts a list of integer codepoints to a string.</p>

<p>In case the conversion fails, it raises a <code>String.UnicodeConversionError</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.from_char_list!([0x00E6, 0x00DF])
&quot;æß&quot;
iex&gt; String.from_char_list!([0x0061, 0x0062, 0x0063])
&quot;abc&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L1179" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="graphemes/1">
    <strong>graphemes(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>graphemes(<a href="#t:t/0">t</a>) :: [<a href="#t:grapheme/0">grapheme</a>]</li>
      
    </ul>
  
  <div class="docstring"><p>Returns unicode graphemes in the string as per Extended Grapheme
Cluster algorithm outlined in the <a href="http://www.unicode.org/reports/tr29/">Unicode Standard Annex #29,
Unicode Text Segmentation</a>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.graphemes(&quot;Ā̀stute&quot;)
[&quot;Ā̀&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;t&quot;,&quot;e&quot;]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L690" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="last/1">
    <strong>last(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>last(<a href="#t:t/0">t</a>) :: <a href="#t:grapheme/0">grapheme</a> | nil</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the last grapheme from an utf8 string,
<code>nil</code> if the string is empty.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.last(&quot;elixir&quot;)
&quot;r&quot;
iex&gt; String.last(&quot;եոգլի&quot;)
&quot;ի&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L742" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="length/1">
    <strong>length(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>length(<a href="#t:t/0">t</a>) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the number of unicode graphemes in an utf8 string.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.length(&quot;elixir&quot;)
6
iex&gt; String.length(&quot;եոգլի&quot;)
5
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L764" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="ljust/2">
    <strong>ljust(subject, len)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>ljust(<a href="#t:t/0">t</a>, pos_integer) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a new string of length <code>len</code> with <code>subject</code> left justified and padded
with <code>padding</code>. If <code>padding</code> is not present, it defaults to whitespace. When
<code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is returned.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.ljust(&quot;abc&quot;, 5)
&quot;abc  &quot;
iex&gt; String.ljust(&quot;abc&quot;, 5, ?-)
&quot;abc--&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L457" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="ljust/3">
    <strong>ljust(subject, len, padding)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>ljust(<a href="#t:t/0">t</a>, pos_integer, char) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"></div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L461" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="lstrip/1">
    <strong>lstrip(binary)</strong>
  </p>
  
  <div class="docstring"><p>Returns a string where leading Unicode whitespace
has been removed.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.lstrip(&quot;   abc  &quot;)
&quot;abc  &quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L362" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="lstrip/2">
    <strong>lstrip(other, char)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>lstrip(<a href="#t:t/0">t</a>, char) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a string where leading <code>char</code> have been removed.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.lstrip(&quot;_  abc  _&quot;, ?_)
&quot;  abc  _&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L376" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="next_codepoint/1">
    <strong>next_codepoint(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>next_codepoint(<a href="#t:t/0">t</a>) :: {<a href="#t:codepoint/0">codepoint</a>, <a href="#t:t/0">t</a>} | :no_codepoint</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the next codepoint in a String.</p>

<p>The result is a tuple with the codepoint and the
remaining of the string or <code>:no_codepoint</code> in case
the string reached its end.</p>

<p>As with other functions in the String module, this
function does not check for the validity of the codepoint.
That said, if an invalid codepoint is found, it will
be returned by this function.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.next_codepoint(&quot;josé&quot;)
{ &quot;j&quot;, &quot;osé&quot; }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L621" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="next_grapheme/1">
    <strong>next_grapheme(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>next_grapheme(<a href="#t:t/0">t</a>) :: {<a href="#t:grapheme/0">grapheme</a>, <a href="#t:t/0">t</a>} | :no_grapheme</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the next grapheme in a String.</p>

<p>The result is a tuple with the grapheme and the
remaining of the string or <code>:no_grapheme</code> in case
the String reached its end.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.next_grapheme(&quot;josé&quot;)
{ &quot;j&quot;, &quot;osé&quot; }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L707" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="printable?/1">
    <strong>printable?(arg1)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>printable?(<a href="#t:t/0">t</a>) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Checks if a string is printable considering it is encoded
as UTF-8. Returns <code>true</code> if so, <code>false</code> otherwise.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.printable?(&quot;abc&quot;)
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L134" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="replace/4">
    <strong>replace(subject, pattern, replacement, options // [])</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>replace(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>, <a href="Keyword.html#t:t/0">Keyword.t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a new binary based on <code>subject</code> by replacing the parts
matching <code>pattern</code> by <code>replacement</code>. By default, it replaces
all entries, except if the <code>global</code> option is set to <code>false</code>.</p>

<p>A <code>pattern</code> may be a string or a regex.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;-&quot;)
&quot;a-b-c&quot;
iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;-&quot;, global: false)
&quot;a-b,c&quot;
</code></pre>

<p>The pattern can also be a regex. In those cases, one can give <code>\N</code>
in the <code>replacement</code> string to access a specific catpure in the regex:</p>

<pre><code>iex&gt; String.replace(&quot;a,b,c&quot;, %r/,(.)/, &quot;,\\1\\1&quot;)
&quot;a,bb,cc&quot;
</code></pre>

<p>Notice we had to escape the escape character <code>\</code>. By giving <code>&amp;</code>,
one can inject the whole matched pattern in the replacement string.</p>

<p>When strings are used as a pattern, a developer can also use the
replaced part inside the <code>replacement</code> via the <code>:insert_replaced</code> option:</p>

<pre><code>iex&gt; String.replace(&quot;a,b,c&quot;, &quot;b&quot;, &quot;[]&quot;, insert_replaced: 1)
&quot;a,[b],c&quot;
iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;[]&quot;, insert_replaced: 2)
&quot;a[],b[],c&quot;
iex&gt; String.replace(&quot;a,b,c&quot;, &quot;,&quot;, &quot;[]&quot;, insert_replaced: [1, 1])
&quot;a[,,]b[,,]c&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L522" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="reverse/1">
    <strong>reverse(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>reverse(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Reverses the given string. Works on graphemes.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.reverse(&quot;abcd&quot;)
&quot;dcba&quot;
iex&gt; String.reverse(&quot;hello world&quot;)
&quot;dlrow olleh&quot;
iex&gt; String.reverse(&quot;hello ∂og&quot;)
&quot;go∂ olleh&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L557" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="rjust/2">
    <strong>rjust(subject, len)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>rjust(<a href="#t:t/0">t</a>, pos_integer) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a new string of length <code>len</code> with <code>subject</code> right justified and
padded with <code>padding</code>. If <code>padding</code> is not present, it defaults to
whitespace. When <code>len</code> is less than the length of <code>subject</code>, <code>subject</code> is
returned.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.rjust(&quot;abc&quot;, 5)
&quot;  abc&quot;
iex&gt; String.rjust(&quot;abc&quot;, 5, ?-)
&quot;--abc&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L433" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="rjust/3">
    <strong>rjust(subject, len, padding)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>rjust(<a href="#t:t/0">t</a>, pos_integer, char) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"></div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L437" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="rstrip/1">
    <strong>rstrip(binary)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>rstrip(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a string where trailing Unicode whitespace
has been removed.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.rstrip(&quot;   abc  &quot;)
&quot;   abc&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L310" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="rstrip/2">
    <strong>rstrip(string, char)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>rstrip(<a href="#t:t/0">t</a>, char) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a string where trailing <code>char</code> have been removed.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.rstrip(&quot;   abc _&quot;, ?_)
&quot;   abc &quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L323" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="slice/2">
    <strong>slice(string, range)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>slice(<a href="#t:t/0">t</a>, <a href="Range.html#t:t/0">Range.t</a>) :: <a href="#t:t/0">t</a> | nil</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a substring from the offset given by the start of the
range to the offset given by the end of the range.</p>

<p>If the start of the range is not a valid offset for the given
string or if the range is in reverse order, returns <code>nil</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.slice(&quot;elixir&quot;, 1..3)
&quot;lix&quot;
iex&gt; String.slice(&quot;elixir&quot;, 1..10)
&quot;lixir&quot;
iex&gt; String.slice(&quot;elixir&quot;, 10..3)
nil

iex&gt; String.slice(&quot;elixir&quot;, -4..-1)
&quot;ixir&quot;
iex&gt; String.slice(&quot;elixir&quot;, 2..-1)
&quot;ixir&quot;
iex&gt; String.slice(&quot;elixir&quot;, -4..6)
&quot;ixir&quot;
iex&gt; String.slice(&quot;elixir&quot;, -1..-4)
nil
iex&gt; String.slice(&quot;elixir&quot;, -10..-7)
nil

iex&gt; String.slice(&quot;a&quot;, 0..1500)
&quot;a&quot;
iex&gt; String.slice(&quot;a&quot;, 1..1500)
&quot;&quot;
iex&gt; String.slice(&quot;a&quot;, 2..1500)
nil
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L899" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="slice/3">
    <strong>slice(string, start, len)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>slice(<a href="#t:t/0">t</a>, integer, integer) :: <a href="#t:grapheme/0">grapheme</a> | nil</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a substring starting at the offset given by the first, and
a length given by the second.
If the offset is greater than string length, than it returns <code>nil</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.slice(&quot;elixir&quot;, 1, 3)
&quot;lix&quot;
iex&gt; String.slice(&quot;elixir&quot;, 1, 10)
&quot;lixir&quot;
iex&gt; String.slice(&quot;elixir&quot;, 10, 3)
nil
iex&gt; String.slice(&quot;elixir&quot;, -4, 4)
&quot;ixir&quot;
iex&gt; String.slice(&quot;elixir&quot;, -10, 3)
nil
iex&gt; String.slice(&quot;a&quot;, 0, 1500)
&quot;a&quot;
iex&gt; String.slice(&quot;a&quot;, 1, 1500)
&quot;&quot;
iex&gt; String.slice(&quot;a&quot;, 2, 1500)
nil
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L843" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="split/1">
    <strong>split(binary)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>split(<a href="#t:t/0">t</a>) :: [<a href="#t:t/0">t</a>]</li>
      
    </ul>
  
  <div class="docstring"><p>Divides a string into substrings at each Unicode whitespace
occurrence with leading and trailing whitespace ignored.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.split(&quot;foo bar&quot;)
[&quot;foo&quot;, &quot;bar&quot;]
iex&gt; String.split(&quot;foo&quot; &lt;&gt; &lt;&lt;194, 133&gt;&gt; &lt;&gt; &quot;bar&quot;)
[&quot;foo&quot;, &quot;bar&quot;]
iex&gt; String.split(&quot; foo bar &quot;)
[&quot;foo&quot;, &quot;bar&quot;]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L169" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="split/3">
    <strong>split(binary, pattern, options // [])</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>split(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>] | <a href="Regex.html#t:t/0">Regex.t</a>, <a href="Keyword.html#t:t/0">Keyword.t</a>) :: [<a href="#t:t/0">t</a>]</li>
      
    </ul>
  
  <div class="docstring"><p>Divides a string into substrings based on a pattern,
returning a list of these substrings. The pattern can
be a string, a list of strings or a regular expression.</p>

<p>The string is split into as many parts as possible by
default, unless the <code>global</code> option is set to <code>false</code>.</p>

<p>Empty strings are only removed from the result if the
<code>trim</code> option is set to <code>true</code>.</p>

<h2>Examples</h2>

<p>Splitting with a string pattern:</p>

<pre><code>iex&gt; String.split(&quot;a,b,c&quot;, &quot;,&quot;)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
iex&gt; String.split(&quot;a,b,c&quot;, &quot;,&quot;, global: false)
[&quot;a&quot;, &quot;b,c&quot;]
iex&gt; String.split(&quot; a b c &quot;, &quot; &quot;, trim: true)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>

<p>A list of patterns:</p>

<pre><code>iex&gt; String.split(&quot;1,2 3,4&quot;, [&quot; &quot;, &quot;,&quot;])
[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]
</code></pre>

<p>A regular expression:</p>

<pre><code>iex&gt; String.split(&quot;a,b,c&quot;, %r{,})
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
iex&gt; String.split(&quot;a,b,c&quot;, %r{,}, global: false)
[&quot;a&quot;, &quot;b,c&quot;]
iex&gt; String.split(&quot; a b c &quot;, %r{\s}, trim: true)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>

<p>Splitting on empty patterns returns codepoints:</p>

<pre><code>iex&gt; String.split(&quot;abc&quot;, %r{})
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
iex&gt; String.split(&quot;abc&quot;, &quot;&quot;)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
iex&gt; String.split(&quot;abc&quot;, &quot;&quot;, trim: true)
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
iex&gt; String.split(&quot;abc&quot;, &quot;&quot;, global: false)
[&quot;a&quot;, &quot;bc&quot;]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L221" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="starts_with?/2">
    <strong>starts_with?(string, prefixes)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>starts_with?(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a> | [<a href="#t:t/0">t</a>]) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>string</code> starts with any of the prefixes given, otherwise
<code>false</code>. <code>prefixes</code> can be either a single prefix or a list of prefixes.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.starts_with? &quot;elixir&quot;, &quot;eli&quot;
true
iex&gt; String.starts_with? &quot;elixir&quot;, [&quot;erlang&quot;, &quot;elixir&quot;]
true
iex&gt; String.starts_with? &quot;elixir&quot;, [&quot;erlang&quot;, &quot;ruby&quot;]
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L976" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="strip/1">
    <strong>strip(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>strip(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a string where leading/trailing Unicode whitespace
has been removed.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.strip(&quot;   abc  &quot;)
&quot;abc&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L396" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="strip/2">
    <strong>strip(string, char)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>strip(<a href="#t:t/0">t</a>, char) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Returns a string where leading/trailing <code>char</code> have been
removed.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.strip(&quot;a  abc  a&quot;, ?a)
&quot;  abc  &quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L412" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="to_char_list/1">
    <strong>to_char_list(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>to_char_list(<a href="String.html#t:t/0">String.t</a>) :: {:ok, char_list} | {:error, [], binary} | {:incomplete, [], binary}</li>
      
    </ul>
  
  <div class="docstring"><p>Converts a string into a char list converting each codepoint to its
respective integer value.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.to_char_list(&quot;æß&quot;)
{ :ok, &#39;æß&#39; }
iex&gt; String.to_char_list(&quot;abc&quot;)
{ :ok, &#39;abc&#39; }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L1098" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="to_char_list!/1">
    <strong>to_char_list!(string)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>to_char_list!(<a href="String.html#t:t/0">String.t</a>) :: char_list | no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Converts a string into a char list converting each codepoint to its
respective integer value.</p>

<p>In case the conversion fails or is incomplete,
it raises a <code>String.UnicodeConversionError</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.to_char_list!(&quot;æß&quot;)
&#39;æß&#39;
iex&gt; String.to_char_list!(&quot;abc&quot;)
&#39;abc&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L1127" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="upcase/1">
    <strong>upcase(binary)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>upcase(<a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Convert all characters on the given string to uppercase.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.upcase(&quot;abcd&quot;)
&quot;ABCD&quot;
iex&gt; String.upcase(&quot;ab 123 xpto&quot;)
&quot;AB 123 XPTO&quot;
iex&gt; String.upcase(&quot;josé&quot;)
&quot;JOSÉ&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L256" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="valid?/1">
    <strong>valid?(arg1)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>valid?(<a href="#t:t/0">t</a>) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Checks whether <code>str</code> contains only valid characters.</p>

<h2>Examples</h2>

<pre><code>iex&gt; String.valid?(&quot;a&quot;)
true
iex&gt; String.valid?(&quot;ø&quot;)
true
iex&gt; String.valid?(&lt;&lt;0xffff :: 16&gt;&gt;)
false
iex&gt; String.valid?(&quot;asd&quot; &lt;&gt; &lt;&lt;0xffff :: 16&gt;&gt;)
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L647" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="valid_character?/1">
    <strong>valid_character?(codepoint)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>valid_character?(<a href="#t:t/0">t</a>) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Checks whether <code>str</code> is a valid character.</p>

<p>All characters are codepoints, but some codepoints
are not valid characters. They may be reserved, private,
or other.</p>

<p>More info at: <a href="http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters">http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters</a></p>

<h2>Examples</h2>

<pre><code>iex&gt; String.valid_character?(&quot;a&quot;)
true
iex&gt; String.valid_character?(&quot;ø&quot;)
true
iex&gt; String.valid_character?(&quot;\x{ffff}&quot;)
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/lib/elixir/lib/string.ex#L675" target="_blank" class="view_source">Source</a>
  
</div>

        </div>
      

      

      
    </div>
  </body>
</html>
