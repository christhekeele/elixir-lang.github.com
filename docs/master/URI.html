<!DOCTYPE html>
<html>
  <head>
    <title>URI</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        URI
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>Utilities for working with and creating URIs.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L1" target="_blank" class="view_source">Source</a>

      

      
        <h2 id="functions_summary">Functions summary</h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#decode/1">decode(arg1)</a></td>
  
    <td class="summary_synopsis"><p>Unpercent (URL) decodes a URI.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#decode_query/2">decode_query(q, dict // HashDict.new())</a></td>
  
    <td class="summary_synopsis"><p>Given a query string of the form &quot;key1=value1&amp;key=value2...&quot;, produces an
orddict with one entry for each key-value pair. Each key and value will be a
binary. It also does percent-unescaping of both keys and values.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#default_port/1">default_port(scheme)</a></td>
  
    <td class="summary_synopsis"><p>Returns the default port for a given scheme.
If the scheme is unknown to URI, returns <code>nil</code>.
Any scheme may be registered via <a href="#default_port/2"><code>default_port/2</code></a>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#default_port/2">default_port(scheme, port)</a></td>
  
    <td class="summary_synopsis"><p>Registers a scheme with a default port.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#encode/1">encode(s)</a></td>
  
    <td class="summary_synopsis"><p>Percent (URL) encodes a URI.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#encode_query/1">encode_query(l)</a></td>
  
    <td class="summary_synopsis"><p>Takes an enumerable (containing a sequence of two-item tuples)
and returns a string of the form &quot;k=v&amp;k2=v2...&quot; where keys and values are
URL encoded as per <a href="#encode/1"><code>encode/1</code></a>. Keys and values can be any term
that implements the <code>String.Chars</code> protocol (i.e. can be converted
to a binary).</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#normalize_scheme/1">normalize_scheme(scheme)</a></td>
  
    <td class="summary_synopsis"><p>Normalizes the scheme according to the spec by downcasing it.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#parse/1">parse(s)</a></td>
  
    <td class="summary_synopsis"><p>Parses a URI into components.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#query_decoder/1">query_decoder(q)</a></td>
  
    <td class="summary_synopsis"><p>Returns an iterator function over the query string that decodes
the query string in steps.</p>
</td>
  
</tr>

        </table>
      

      

      

      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="decode/1">
    <strong>decode(arg1)</strong>
  </p>
  
  <div class="docstring"><p>Unpercent (URL) decodes a URI.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L129" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="decode_query/2">
    <strong>decode_query(q, dict // HashDict.new())</strong>
  </p>
  
  <div class="docstring"><p>Given a query string of the form &quot;key1=value1&amp;key=value2...&quot;, produces an
orddict with one entry for each key-value pair. Each key and value will be a
binary. It also does percent-unescaping of both keys and values.</p>

<p>Use <a href="#query_decoder/1"><code>query_decoder/1</code></a> if you want to iterate over each value manually.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L66" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="default_port/1">
    <strong>default_port(scheme)</strong>
  </p>
  
  <div class="docstring"><p>Returns the default port for a given scheme.
If the scheme is unknown to URI, returns <code>nil</code>.
Any scheme may be registered via <a href="#default_port/2"><code>default_port/2</code></a>.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L23" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="default_port/2">
    <strong>default_port(scheme, port)</strong>
  </p>
  
  <div class="docstring"><p>Registers a scheme with a default port.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L45" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="encode/1">
    <strong>encode(s)</strong>
  </p>
  
  <div class="docstring"><p>Percent (URL) encodes a URI.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L107" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="encode_query/1">
    <strong>encode_query(l)</strong>
  </p>
  
  <div class="docstring"><p>Takes an enumerable (containing a sequence of two-item tuples)
and returns a string of the form &quot;k=v&amp;k2=v2...&quot; where keys and values are
URL encoded as per <a href="#encode/1"><code>encode/1</code></a>. Keys and values can be any term
that implements the <code>String.Chars</code> protocol (i.e. can be converted
to a binary).</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L57" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="normalize_scheme/1">
    <strong>normalize_scheme(scheme)</strong>
  </p>
  
  <div class="docstring"><p>Normalizes the scheme according to the spec by downcasing it.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L22" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="parse/1">
    <strong>parse(s)</strong>
  </p>
  
  <div class="docstring"><p>Parses a URI into components.</p>

<p>URIs have portions that are handled specially for the
particular scheme of the URI. For example, http and https
have different default ports. Sometimes the parsing
of portions themselves are different. This parser
is extensible via behavior modules. If you have a
module named <code>URI.MYSCHEME</code> with a function called
<code>parse</code> that takes a single argument, the generically
parsed URI, that function will be called when this
parse function is passed a URI of that scheme. This
allows you to build on top of what the URI library
currently offers. You also need to define <code>default_port</code>
which takes no arguments and returns the default port
for that particular scheme. Take a look at <code>URI.HTTPS</code> for an
example of one of these extension modules.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L164" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="query_decoder/1">
    <strong>query_decoder(q)</strong>
  </p>
  
  <div class="docstring"><p>Returns an iterator function over the query string that decodes
the query string in steps.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/e6be0628ce014ee70a2407e09f7f0e3a9f778ed8/lib/elixir/lib/uri.ex#L74" target="_blank" class="view_source">Source</a>
  
</div>

        </div>
      

      

      
    </div>
  </body>
</html>
